// IEC 61131-3 Structured Text Grammar for Lezer
// Simplified grammar to avoid token conflicts

@top Program { statement* }

@skip { space | LineComment | BlockComment }

// ============================================================================
// Statements
// ============================================================================

statement {
  ProgramDecl |
  FunctionBlockDecl |
  VarBlock |
  Assignment |
  IfStatement |
  CaseStatement |
  ForStatement |
  WhileStatement |
  RepeatStatement |
  FunctionBlockCall |
  ReturnStatement |
  ExitStatement |
  ContinueStatement
}

// ============================================================================
// Program/Function Block Declarations
// ============================================================================

ProgramDecl {
  kw<"PROGRAM"> Identifier
  statement*
  kw<"END_PROGRAM">
}

FunctionBlockDecl {
  kw<"FUNCTION_BLOCK"> Identifier
  statement*
  kw<"END_FUNCTION_BLOCK">
}

// ============================================================================
// Variable Declarations
// ============================================================================

VarBlock {
  VarKeyword
  VariableDecl*
  kw<"END_VAR">
}

VarKeyword {
  kw<"VAR"> |
  kw<"VAR_INPUT"> |
  kw<"VAR_OUTPUT"> |
  kw<"VAR_IN_OUT"> |
  kw<"VAR_TEMP"> |
  kw<"VAR_GLOBAL">
}

VariableDecl {
  VariableList ":" TypeSpec (":" "=" Expression)? ";"
}

VariableList {
  Identifier ("," Identifier)*
}

TypeSpec {
  TypeName |
  ArrayType
}

TypeName {
  kw<"BOOL"> |
  kw<"INT"> |
  kw<"SINT"> |
  kw<"DINT"> |
  kw<"LINT"> |
  kw<"UINT"> |
  kw<"USINT"> |
  kw<"UDINT"> |
  kw<"ULINT"> |
  kw<"REAL"> |
  kw<"LREAL"> |
  kw<"TIME"> |
  kw<"STRING"> |
  kw<"BYTE"> |
  kw<"WORD"> |
  kw<"DWORD"> |
  kw<"LWORD"> |
  kw<"TON"> |
  kw<"TOF"> |
  kw<"TP"> |
  kw<"CTU"> |
  kw<"CTD"> |
  kw<"CTUD"> |
  Identifier
}

ArrayType {
  kw<"ARRAY"> "[" Range "]" kw<"OF"> TypeName
}

Range {
  Number ".." Number
}

// ============================================================================
// Assignment
// ============================================================================

Assignment {
  Variable ":=" Expression ";"
}

// ============================================================================
// Control Statements
// ============================================================================

IfStatement {
  kw<"IF"> Expression kw<"THEN">
  statement*
  ElsifClause*
  ElseClause?
  kw<"END_IF"> ";"?
}

ElsifClause {
  kw<"ELSIF"> Expression kw<"THEN">
  statement*
}

ElseClause {
  kw<"ELSE">
  statement*
}

CaseStatement {
  kw<"CASE"> Expression kw<"OF">
  CaseClause+
  ElseClause?
  kw<"END_CASE"> ";"?
}

CaseClause {
  CaseLabel ("," CaseLabel)* ":"
  statement*
}

CaseLabel {
  Number |
  Number ".." Number
}

ForStatement {
  kw<"FOR"> Identifier ":=" Expression kw<"TO"> Expression (kw<"BY"> Expression)?
  kw<"DO">
  statement*
  kw<"END_FOR"> ";"?
}

WhileStatement {
  kw<"WHILE"> Expression kw<"DO">
  statement*
  kw<"END_WHILE"> ";"?
}

RepeatStatement {
  kw<"REPEAT">
  statement*
  kw<"UNTIL"> Expression
  kw<"END_REPEAT"> ";"?
}

ReturnStatement {
  kw<"RETURN"> ";"
}

ExitStatement {
  kw<"EXIT"> ";"
}

ContinueStatement {
  kw<"CONTINUE"> ";"
}

// ============================================================================
// Function Block Calls
// ============================================================================

FunctionBlockCall {
  Identifier "(" NamedArgumentList? ")" ";"?
}

NamedArgumentList {
  NamedArgument ("," NamedArgument)*
}

NamedArgument {
  Identifier ":=" Expression
}

// ============================================================================
// Expressions
// ============================================================================

Expression {
  OrExpression
}

OrExpression {
  AndExpression (kw<"OR"> AndExpression)*
}

AndExpression {
  XorExpression (kw<"AND"> XorExpression)*
}

XorExpression {
  CompareExpression (kw<"XOR"> CompareExpression)*
}

CompareExpression {
  AddExpression (CompareOp AddExpression)?
}

CompareOp {
  "=" | "<>" | "<" | ">" | "<=" | ">="
}

AddExpression {
  MulExpression (("+" | "-") MulExpression)*
}

MulExpression {
  UnaryExpression (("*" | "/" | kw<"MOD">) UnaryExpression)*
}

UnaryExpression {
  ("-" | kw<"NOT">)* PowerExpression
}

PowerExpression {
  PrimaryExpression ("**" PrimaryExpression)*
}

PrimaryExpression {
  Variable |
  Literal |
  FunctionCall |
  "(" Expression ")"
}

Variable {
  Identifier ("." Identifier)*
}

FunctionCall {
  Identifier "(" ArgumentList? ")"
}

ArgumentList {
  Expression ("," Expression)*
}

// ============================================================================
// Literals
// ============================================================================

Literal {
  HexNumber |
  BinaryNumber |
  Number |
  Boolean |
  String |
  TimeLiteral
}

// ============================================================================
// Tokens
// ============================================================================

@tokens {
  Identifier { $[a-zA-Z_] $[a-zA-Z0-9_]* }

  // Hexadecimal literal: 16#FF, 16#DEADBEEF
  HexNumber { "16#" $[0-9a-fA-F]+ }

  // Binary literal: 2#1010, 2#1111_0000
  BinaryNumber { "2#" $[01_]+ }

  Number { $[0-9]+ ("." $[0-9]+)? }

  Boolean { "TRUE" | "FALSE" }

  String { "'" (!['\\] | "\\" _)* "'" | '"' (!["\\] | "\\" _)* '"' }

  // Time literal: T#5s, T#1h30m, TIME#100ms
  TimeLiteral {
    ("T#" | "TIME#") $[0-9a-zA-Z]+
  }

  LineComment { "//" ![\n]* }

  BlockComment { "(*" blockCommentContent* "*)" }

  blockCommentContent { ![*] | "*" ![)] }

  space { $[ \t\n\r]+ }

  "(" ")" "[" "]" "{" "}" ";" ":" ":=" "," ".." "."
  "+" "-" "*" "/" "**" "=" "<>" "<" ">" "<=" ">="

  @precedence { TimeLiteral, HexNumber, BinaryNumber, Boolean, Number, Identifier, LineComment, "/" }
}

// ============================================================================
// Keywords
// ============================================================================

kw<term> { @specialize[@name={term}]<Identifier, term> }
